# 树结构

复习几个概念：二叉排序树，AVL平衡树，红黑树，跳跃表

#### 二叉排序树
* 若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值
* 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值
* 它的左、右子树也分别为排序二叉树

总结：排序二叉树虽然可以快速检索，但在最坏的情况下：如果插入的节点集本身就是有序的，要么是由小到大排列，要么是由大到小排列，那么最后得到 的排序二叉树将变成链表：所有节点只有左节点（如果插入节点集本身是大到小排列）；或所有节点只有右节点（如果插入节点集本身是小到大排列）。在这种情况 下，排序二叉树就变成了普通链表，其检索效率就会很差。

#### AVL平衡树：在二叉排序树的基础上 
* ALV树中任何两个结点的高度差值最大不超过1。

总结：若查找树的所有的节点向一边倾斜，这时候的查找就退化为线性查找，复杂度为n

#### 红黑树
1. 性质1：每个节点要么是红色，要么是黑色。
2. 性质2：根节点永远是黑色的。
3. 性质3：所有的叶节点都是空节点（即 null），并且是黑色的。
4. 性质4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）
5. 性质5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。

总结： 红黑树能够以O(log2(N))的时间复杂度进行搜索、插入、删除操作。此外,任何不平衡都会在3次旋转之内解决。这一点是AVL所不具备的。

---

前驱节点：前驱节点val值小于该节点val值并且值最大的节点
后继节点：后继节点val值大于该节点val值并且值最小的节点

---

右旋： 右旋N节点，N节点的左孩子为NL ， N节点的右孩子 NR，N节点的父节点NP
1、NL 替代N节点的位置
2、NL的右节点 挂在N节点的左孩子下
3、N节点挂在N-L的右孩子下
思路
1、记录下NL
2、把NL的右孩子 指向 N的左孩子  & N的左孩子指向NL的右孩子
3、NL 替换N的位置
4、NL的右孩子指向N  N的父节点指向NL

```
		private void rotateRight(Entry<K,V> p) {
        if (p != null) {
            Entry<K,V> l = p.left;//思路step1
            p.left = l.right;//思路step2
            if (l.right != null) 
					l.right.parent = p;//思路step2
            l.parent = p.parent;//思路step3
            if (p.parent == null)
                root = l;//思路step2
            else if (p.parent.right == p)
                p.parent.right = l;//思路step2
            else p.parent.left = l;//思路step2

            l.right = p;//思路step4
            p.parent = l;//思路step4
        }
    }
```


左旋：和右旋对称  留给读者自己编写



#### 跳跃表
在底层有序列表（存储真正数据的节点）之上，维护关键节点的有序列表（可以有多层） 数据先和关键节点比较，关键节点记录着他对应的 right down节点的数据，比较找到底层有序列表。


源码参考：
红黑树：TreeSet
跳跃表：ConcurrentSkipListMap
二叉搜索树：com.ido.jdk.collections.tree.BinarySearchTree
AVL树：com.ido.jdk.collections.tree.AvlTree


#数据结构