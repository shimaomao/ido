

[B站 -深入理解JVVA虚拟机](https://www.bilibili.com/video/av29502877?from=search&seid=17563618053604661912)

###### 


###### 栈，程序计数器，虚拟机栈
        线程方法执行完就没有了，不存在回收不回收的问题
        
###### 堆回收
        对象是否死掉的判断
        引用计数法  存在A B相互引用的问题
        可达性分析算法 GC Roots是否可达
        
###### GC Roots包括以下几种
        1、虚拟机栈应用的对象
        2、方法区中类静态属性引用的对象
        3、方法区中常量引用的对象
        4、本地方法栈中JNI引用的对象
        
        强引用
        软引用 SoftReference  内存不够直接回收的
        弱引用 WeakReference   垃圾回收扫描到这个对象就会回收
        虚引用 PhantomReference 对象被回收 得打哦一个系统通知 cleaner
        sun.misc.Cleaner   jdk的直接内存回收就使用了这个
        
        
        可达性达不到的时候，也不是直接死的，判断下是否要执行finalize()方法，如果需要执行的话，会把对象会放到一个F-Queue队列中，虚拟机分配一个线程去执行他，不承诺等它执行结束 防止死循环。
        
        方法区回收  -- 回收效果很差  
        常量池回收
        比如一个字符串 进入常量池，但是gc的时候 发现没有任何对象应用了它，这个时候就可以回收
        类回收
        不存在改类实例，加载这个类的classloader被回收了，对应的class无法在任何地方被反射调用访问
        
        
###### 垃圾回收算法
        1、标记-清除  （ 碎片多，标记和清除效率一般）
        2、复制（存活的copy到另外一块空间就可以了 ，需要额外的一块空间）
        3、标记整理（解决碎片问题，不需要额外的空间）
        
        大对象 新生代放不下 老年代担保 直接进入老年代
        
        分代收集算法
        新生代  回收的比较多，存活少 用复制 
        老年代  需要回收的少  用标记 清除  或者 标记整理
        
        
![垃圾回收器配合使用]( /ido-jvm/image/垃圾回收器.jpg)        
###### 垃圾回收器
        
        垃圾回收器 新生代 老年代 说明 
        Serial 复制  单线程收集 会Stop The World 
        ParNew 复制  Serial的多线程版本，多核cpu才能发挥它的作用 
        Parallel Scavenge 复制  并发收集，更关注吞吐量和停顿时间。新生代eden区和suvivor区的比例能自动调节（需要设定参数） 
        Serial Old  标记整理 单线程回收 
        Parallel Old  标记整理  多线程版本回收 jdk1.6版本才出来 
        CMS  标记清理 并发标记清理，停顿时间短比较占cpu ,默认是回收线程数 =  (cpu +3)/4Serial Old是CMS的备选 
        G1     https://www.cnblogs.com/aspirant/p/8663872.html

