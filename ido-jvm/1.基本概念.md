

[B站 -深入理解JVVA虚拟机](https://www.bilibili.com/video/av29502877?from=search&seid=17563618053604661912)

###### 虚拟机
        HotSpot
        JRockit
        TaobaoVM
        etc
###### 内存区域
        线程共享：方法区  & JAVA堆
        线程独占：虚拟机栈 & 本地方法栈  & 程序计数器 

###### 程序计数器
        1.线程私有
        2.可以看做当前线程所执行的字节码的行号指示器
        3.如果线程执行的是java方法，那么计数器记录的是执行虚拟机字节码指令的地址，如果是执行native方法，那么计数器是undefined
        4.此区域是唯一一个在java虚拟机规范中没有规定OOM情况的区域
        
###### 虚拟机栈
        1.线程私有 
        2.虚拟机栈描述的是java方法执行的动态内存模型
        3.栈帧
            每个方法执行 都会创建一个栈帧，伴随着方法从创建到 执行完成。
            用于存储局部变量表，操作数栈，动态链接，方法出口等信息
        4.局部变量表：
            用来保存编译期间可知的各种数据类型，对象引用，returnAdress等

        如果当前线程请求的栈深度大于虚拟机允许的最大深度，会抛出 StackOverflowError异常
###### 本地方法栈 
        和虚拟机栈一样，只不过是执行native方法，有些虚拟机（HotSpot）把虚拟机栈和本地方法栈合二为一

###### 堆内存
        最大的一块内存空间 垃圾回收的主要区域 [线程共享] 
        GC的主要对象
        内存不够会抛出OutOfMemoryError异常
        
###### 方法区
        用于存储被加载的类信息，常量，静态变量[线程共享]
        jdk8-->元数据
        
###### 运行时常量池-->属于方法区的一块
        String name1 = "abc";
        String name2 = "abc";
        字符串直接进到常量池里面
        name1 == name2  （true）
        String name3 = new String("abc");
        name2 == name3 (false 堆中有一个对象 指向运行时常量池)
        name2 == name3.intern() (true  intern相当于把字符串扔到运行时常量池里面去 如果已经有了 就用原来的 )
        
        
        jdk1.6 intern() 相当于把字符串扔到常量池里面去，如果已经有了，就返回原来的常量池中的对象
        
        jdk1.7 intern() 只会在常量池中记录首次出现的实例的引用 
        
        
    
###### 直接内存
        不属于JVM管理，但是受限于物理内存
        当jvm内存  + 直接内存> 物理内存 也会oom
       
###### 对象在内存中的布局
        TLAB 线程本地分配缓存区  多线程分配对象提升性能
        
###### 对象结构  
        对象头 hashcode gc年龄 锁信息  类型指针
        实例数据  
        对齐填充 hotspot 必须是8字节的整数倍 不够需要填充
              

###### 对象的访问定位     
        使用句柄
        直接指针（hotspot）
           
###### 垃圾回收
        判断什么对象为垃圾？
        如何回收？
        何时回收？
        
###### 判断对象是否还存活        
        对象是否死掉的判断
        引用计数法  存在A B相互引用的问题
        可达性分析算法 GC Roots是否可达
        
###### GC Roots包括以下几种
        1、虚拟机栈应用的对象
        2、方法区中类静态属性引用的对象
        3、方法区中常量引用的对象
        4、本地方法栈中JNI引用的对象
        
        强引用
        软引用 SoftReference  内存不够直接回收的
        弱引用 WeakReference   垃圾回收扫描到这个对象就会回收
        虚引用 PhantomReference 对象被回收 得打哦一个系统通知 cleaner
        sun.misc.Cleaner   jdk的直接内存回收就使用了这个
        
        
        可达性达不到的时候，也不是直接死的，判断下是否要执行finalize()方法，如果需要执行的话，会把对象会放到一个F-Queue队列中，虚拟机分配一个线程去执行他，不承诺等它执行结束 防止死循环。
        
        方法区回收  -- 回收效果很差  
        常量池回收
        比如一个字符串 进入常量池，但是gc的时候 发现没有任何对象应用了它，这个时候就可以回收
        类回收
        不存在改类实例，加载这个类的classloader被回收了，对应的class无法在任何地方被反射调用访问
 
        
###### 垃圾回收算法
        1、标记-清除  （ 碎片多，标记和清除效率一般）
        2、复制（存活的copy到另外一块空间就可以了 ，需要额外的一块空间）
        3、标记整理（解决碎片问题，不需要额外的空间）
        
        大对象 新生代放不下 老年代担保 直接进入老年代
        
        分代收集算法
        新生代  回收的比较多，存活少 用复制 
        老年代  需要回收的少  用标记 清除  或者 标记整理
        
        
![垃圾回收器配合使用]( /ido-jvm/image/垃圾回收器.jpg)        
###### 垃圾回收器
        
        垃圾回收器 新生代 老年代 说明 
        Serial 复制  单线程收集 会Stop The World 
        ParNew 复制  Serial的多线程版本，多核cpu才能发挥它的作用 
        Parallel Scavenge 复制  并发收集，更关注吞吐量和停顿时间。新生代eden区和suvivor区的比例能自动调节（需要设定参数） 
        Serial Old  标记整理 单线程回收 
        Parallel Old  标记整理  多线程版本回收 jdk1.6版本才出来 
        CMS  并发收集，停顿时间短比较占cpu ,默认是回收线程数 =  (cpu +3)/4Serial Old是CMS的备选  碎片多，cpu占用多
            初始标记 stop the world 找到gc root
            并发标记 根据gcroot找可以回收的对象标记
            重新标记 stop the world 重新标记 修正
            并发清理 最后并发清理
        G1     https://www.cnblogs.com/aspirant/p/8663872.html

######  何时进行垃圾回收？

###### 内存分配 
###### 虚拟机工具 jps 
###### 虚拟机工具 jstat
###### 虚拟机工具 jinfo
###### 虚拟机工具 jhat
###### 虚拟机工具 jstack
###### 虚拟机可视化 jconsole
###### 虚拟机可视化 jvisualvm
###### 性能调优
###### Class结构
###### 类加载
###### happens-before
###### 重排序
###### 锁的内存语义
###### volatile内存语义
###### final域内存语义